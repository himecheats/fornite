//game structs
//uintptr_t _displayName = il2cpp::value(_("BasePlayer"), _("_displayName"));
//uintptr_t movement = il2cpp::value(_("BasePlayer"), _("movement"));
//uintptr_t player_inventory = il2cpp::value(_("BasePlayer"), _("inventory"));
//uintptr_t clActiveItem = il2cpp::value(_("BasePlayer"), _("clActiveItem"));
//uintptr_t playerModel = il2cpp::value(_("BasePlayer"), _("playerModel"));
//uintptr_t clientTeam = il2cpp::value(_("BasePlayer"), _("clientTeam"));
//uintptr_t playerFlags = il2cpp::value(_("BasePlayer"), _("playerFlags"));
//uintptr_t clientTickInterval = il2cpp::value(_("BasePlayer"), _("clientTickInterval"));
//uintptr_t eyes = il2cpp::value(_("BasePlayer"), _("eyes"));
//uintptr_t lastSentTickTime = il2cpp::value(_("BasePlayer"), _("lastSentTickTime"));
//uintptr_t modelState = il2cpp::value(_("BasePlayer"), _("modelState"));
//uintptr_t input = il2cpp::value(_("BasePlayer"), _("input"));
//uintptr_t containerBelt = il2cpp::value(_("PlayerInventory"), _("containerBelt"));
//uintptr_t containerWear = il2cpp::value(_("PlayerInventory"), _("containerWear"));
//uintptr_t itemList = il2cpp::value(_("ItemContainer"), _("itemList"));
//uintptr_t userID = il2cpp::value(_("BasePlayer"), _("userID"));
//uintptr_t mounted = il2cpp::value(_("BasePlayer"), _("mounted"));
//
//uintptr_t newVelocity = il2cpp::value(_("PlayerModel"), _("newVelocity"));
//uintptr_t isLocalPlayer = il2cpp::value(_("PlayerModel"), _("isLocalPlayer"));
//
//uintptr_t _health = il2cpp::value(_("BaseCombatEntity"), _("_health"));
//uintptr_t _maxHealth = il2cpp::value(_("BaseCombatEntity"), _("_maxHealth"));
//uintptr_t lifestate = il2cpp::value(_("BaseCombatEntity"), _("lifestate"));
//
//uintptr_t net = il2cpp::value(_("BaseNetworkable"), _("net"));
//
//uintptr_t heldEntity = il2cpp::value(_("Item"), _("heldEntity"));
//
//uintptr_t canWieldItems = il2cpp::value(_("BaseMountable"), _("canWieldItems"));
//
//uintptr_t recoil = il2cpp::value(_("BaseProjectile"), _("recoil"));
//uintptr_t automatic = il2cpp::value(_("BaseProjectile"), _("automatic"));
//
//uintptr_t aimSway = il2cpp::value(_("BaseProjectile"), _("aimSway"));
//uintptr_t aimSwaySpeed = il2cpp::value(_("BaseProjectile"), _("aimSwaySpeed"));
//uintptr_t primaryMagazine = il2cpp::value(_("BaseProjectile"), _("primaryMagazine"));
//
//uintptr_t aimCone = il2cpp::value(_("BaseProjectile"), _("aimCone"));
//uintptr_t hipAimCone = il2cpp::value(_("BaseProjectile"), _("hipAimCone"));
//uintptr_t aimConePenaltyMax = il2cpp::value(_("BaseProjectile"), _("aimConePenaltyMax"));
//uintptr_t aimconePenaltyPerShot = il2cpp::value(_("BaseProjectile"), _("aimconePenaltyPerShot"));
//uintptr_t stancePenaltyScale = il2cpp::value(_("BaseProjectile"), _("stancePenaltyScale"));
//
//uintptr_t successFraction = il2cpp::value(_("FlintStrikeWeapon"), _("successFraction"));
//uintptr_t didSparkThisFrame = il2cpp::value(_("FlintStrikeWeapon"), _("_didSparkThisFrame"));
//
//uintptr_t currentVelocity = il2cpp::value(_("Projectile"), _("currentVelocity"));
//uintptr_t currentPosition = il2cpp::value(_("Projectile"), _("currentPosition"));
//uintptr_t thickness_addr = il2cpp::value(_("Projectile"), _("thickness"));
//uintptr_t projectileVelocityScale_addr = il2cpp::value(_("BaseProjectile"), _("projectileVelocityScale"));
//uintptr_t mod = il2cpp::value(_("Projectile"), _("mod"));
//uintptr_t hitTest = il2cpp::value(_("Projectile"), _("hitTest"));
//
//uintptr_t damageProperties = il2cpp::value(_("BaseMelee"), _("damageProperties"));
//
//uintptr_t weakspots = il2cpp::value(_("BaseHelicopter"), _("weakspots"));
//
////uintptr_t info = il2cpp::value(_("Item"), _("info"));
//
//uintptr_t iconSprite = il2cpp::value(_("ItemDefinition"), _("iconSprite"));
//uintptr_t steamItem = il2cpp::value(_("ItemDefinition"), _("steamItem"));
//
//uintptr_t category = il2cpp::value(_("ItemDefinition"), _("category"));
//uintptr_t itemid = il2cpp::value(_("ItemDefinition"), _("itemid"));
//uintptr_t displayName = il2cpp::value(_("ItemDefinition"), _("displayName"));
//
//uintptr_t viewOffset = il2cpp::value(_("PlayerEyes"), _("viewOffset"));
//
//uintptr_t swimming = il2cpp::value(_("PlayerWalkMovement"), _("swimming"));
//
//uintptr_t lastHitTime = il2cpp::value(_("Chainsaw"), _("lastHitTime"));
//uintptr_t lastHitMaterial = il2cpp::value(_("Chainsaw"), _("lastHitMaterial"));
//uintptr_t gathering = il2cpp::value(_("BaseMelee"), _("gathering"));
//
//uintptr_t nextAttackTime = il2cpp::value(_("AttackEntity"), _("nextAttackTime"));
//uintptr_t timeSinceDeploy = il2cpp::value(_("AttackEntity"), _("timeSinceDeploy"));
//uintptr_t deployDelay = il2cpp::value(_("AttackEntity"), _("deployDelay"));
//uintptr_t repeatDelay = il2cpp::value(_("AttackEntity"), _("repeatDelay"));
//uintptr_t integrity = il2cpp::value(_("Projectile"), _("integrity"));
//
//uintptr_t groundAngleNew = il2cpp::value(_("PlayerWalkMovement"), _("groundAngleNew"));
//uintptr_t landTime = il2cpp::value(_("PlayerWalkMovement"), _("landTime"));
//uintptr_t jumpTime = il2cpp::value(_("PlayerWalkMovement"), _("jumpTime"));
//uintptr_t groundTime = il2cpp::value(_("PlayerWalkMovement"), _("groundTime"));
//uintptr_t gravityMultiplier = il2cpp::value(_("PlayerWalkMovement"), _("gravityMultiplier"));
//uintptr_t flying = il2cpp::value(_("PlayerWalkMovement"), _("flying"));
//
//uintptr_t model = il2cpp::value(_("BaseEntity"), _("model"));
//class base_projectile;
//
//class transform;
//
//class base_player;
//
//class HitTest;
//class modelstate;
//class col;
//
//class weapon;
//
//static auto Line = reinterpret_cast<void (*)(Vector3, Vector3, col, float, bool, bool)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("DDraw"), _("Line"), 6, _(""), _("UnityEngine"))));
//
//static auto GetIndex = reinterpret_cast<int(*)(uintptr_t SkinSetCollection, float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("SkinSetCollection"), _("GetIndex"), 1, _(""), _(""))));
//
//static auto set_onLadder = reinterpret_cast<void(*)(modelstate*, bool)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("ModelState"), _("set_onLadder"), 1, _(""), _(""))));
//
//static auto GetWorldVelocity = reinterpret_cast<Vector3(*)(base_player * base_entity)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("GetWorldVelocity"), 0, _(""), _(""))));
//
////static auto HasPlayerFlag = reinterpret_cast<bool(*)(base_player*, rust::classes::PlayerFlags)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BasePlayer"), _("HasPlayerFlag"), 1, _(""), _(""))));
//
////static auto get_game_object_transform = reinterpret_cast<transform * (*)(uintptr_t game_object)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("GameObject"), _("get_transform"), 0, _(""), _("UnityEngine"))));
//
//static auto get_iconSprite = reinterpret_cast<uintptr_t(*)(weapon * Item)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Item"), _("get_iconSprite"), 0, _(""), _(""))));
//
//static auto get_texture = reinterpret_cast<uintptr_t(*)(uintptr_t sprite)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Sprite"), _("get_texture"), 0, _(""), _("UnityEngine"))));
//
//static auto get_rect = reinterpret_cast<rust::classes::Rect(*)(uintptr_t sprite)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Sprite"), _("get_rect"), 0, _(""), _("UnityEngine"))));
//
//static auto StringPool_Get = reinterpret_cast<unsigned int(*)(rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("StringPool"), _("Get"), 1, _("str"), _(""))));
//
//static auto set_timeScale = reinterpret_cast<void(*)(float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("set_timeScale"), 1, _(""), _("UnityEngine"))));
//
//static auto get_timeScale = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_timeScale"), 0, _(""), _("UnityEngine"))));
//
////static auto FindBone = reinterpret_cast<transform * (*)(base_player*, rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("FindBone"), 1, _(""), _(""))));
//
//static auto get_mousePosition = reinterpret_cast<Vector3(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Input"), _("get_mousePosition"), 0, _(""), _("UnityEngine"))));
//
//static auto FloorToInt = reinterpret_cast<int (*)(float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Mathf"), _("FloorToInt"), 1, _(""), _("UnityEngine"))));
//
//static auto get_gravity = reinterpret_cast<Vector3(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Physics"), _("get_gravity"), 1, _(""), _("UnityEngine"))));
//
//static auto get_isAlive = reinterpret_cast<bool (*)(base_projectile*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Projectile"), _("get_isAlive"), 0, _(""), _(""))));
//
//static auto get_position = reinterpret_cast<Vector3(*)(uintptr_t transform)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("get_position"), 0, _(""), _("UnityEngine"))));
//
//static auto Find = reinterpret_cast<uintptr_t(*)(rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Shader"), _("Find"), 1, _(""), _("UnityEngine"))));
//
//static auto set_hideFlags = reinterpret_cast<void(*)(uintptr_t material, int value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Object"), _("set_hideFlags"), 1, _(""), _("UnityEngine"))));
//
//static auto set_name = reinterpret_cast<void(*)(uintptr_t, rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Object"), _("set_name"), 1, _(""), _("UnityEngine"))));
//
//static auto SetInt = reinterpret_cast<void(*)(uintptr_t material, rust::classes::string name, int value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Material"), _("SetInt"), 1, _(""), _("UnityEngine"))));
//
//static auto get_deltaTime = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_deltaTime"), 0, _(""), _("UnityEngine"))));
//
//static auto get_IsNpc = reinterpret_cast<bool(*)(uintptr_t player_model)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("PlayerModel"), _("get_IsNpc"), -1, _(""), _(""))));
//
//static auto get_time = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_time"), 0, _(""), _("UnityEngine"))));
//
//static auto ClosestPoint = reinterpret_cast<Vector3(*)(base_player*, Vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("ClosestPoint"), 1, _("position"), _(""), 1)));
//
////static auto InverseTransformPoint = reinterpret_cast<vector3(*)(transform*, vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("InverseTransformPoint"), 1, _(""), _("UnityEngine"))));
//
////static auto InverseTransformDirection = reinterpret_cast<vector3(*)(transform*, vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("InverseTransformDirection"), 1, _(""), _("UnityEngine"))));
//
////static auto get_transform = reinterpret_cast<transform * (*)(base_player*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Component"), _("get_transform"), 0, _(""), _("UnityEngine"))));
//
//static auto get_gameObject = reinterpret_cast<uintptr_t(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Component"), _("get_gameObject"), 0, _(""), _("UnityEngine"))));
//
////tatic auto set_position = reinterpret_cast<void(*)(transform*, vector3 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("set_position"), 1, _(""), _("UnityEngine"))));
//
//static auto LookRotation = reinterpret_cast<Vector4(*)(Vector3, Vector3 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Quaternion"), _("LookRotation"), 2, _(""), _("UnityEngine"))));
//
////static auto set_rotation = reinterpret_cast<void(*)(transform*, vector4 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("set_rotation"), 1, _(""), _("UnityEngine"))));
//
//static auto StartAttackCooldown = reinterpret_cast<void(*)(base_projectile*, float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("AttackEntity"), _("StartAttackCooldown"), 1, _(""), _(""))));
//
//static auto ProcessAttack = reinterpret_cast<void(*)(base_projectile*, HitTest*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseMelee"), _("ProcessAttack"), 1, _(""), _(""))));
//
//static auto GetProjectileVelocityScale = reinterpret_cast<float(*)(base_projectile*, bool max)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseProjectile"), _("GetProjectileVelocityScale"), 1, _("getMax"), _(""), 1)));
//
//static auto get_Renderers = reinterpret_cast<rust::list<uintptr_t>*(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("SkinnedMultiMesh"), _("get_Renderers"), 0, _(""), _(""))));
//
//static auto get_material = reinterpret_cast<uintptr_t(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Renderer"), _("get_material"), 0, _(""), _("UnityEngine"))));
//
//
//
//static auto SetColor = reinterpret_cast<void(*)(uintptr_t material, rust::classes::string name, col value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Material"), _("SetColor"), 2, _("name"), _("UnityEngine"), 1)));
//
//float current_time;
//
//void init_bp() {
//	Line = reinterpret_cast<void (*)(Vector3, Vector3, col, float, bool, bool)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("DDraw"), _("Line"), 6, _(""), _("UnityEngine"))));
//	set_onLadder = reinterpret_cast<void(*)(modelstate*, bool)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("ModelState"), _("set_onLadder"), 1, _(""), _(""))));
//	GetWorldVelocity = reinterpret_cast<Vector3(*)(base_player * base_entity)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("GetWorldVelocity"), 0, _(""), _(""))));
//	//	HasPlayerFlag = reinterpret_cast<bool(*)(base_player*, rust::classes::PlayerFlags)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BasePlayer"), _("HasPlayerFlag"), 1, _(""), _(""))));
//	//	get_game_object_transform = reinterpret_cast<transform * (*)(uintptr_t game_object)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("GameObject"), _("get_transform"), 0, _(""), _("UnityEngine"))));
//	get_rect = reinterpret_cast<rust::classes::Rect(*)(uintptr_t sprite)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Sprite"), _("get_rect"), 0, _(""), _("UnityEngine"))));
//	get_iconSprite = reinterpret_cast<uintptr_t(*)(weapon * Item)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Item"), _("get_iconSprite"), 0, _(""), _(""))));
//	steamItem = il2cpp::value(_("ItemDefinition"), _("steamItem"));
//	iconSprite = il2cpp::value(_("ItemDefinition"), _("iconSprite"));
//	get_texture = reinterpret_cast<uintptr_t(*)(uintptr_t sprite)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Sprite"), _("get_texture"), 0, _(""), _("UnityEngine"))));
//	set_name = reinterpret_cast<void(*)(uintptr_t, rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Object"), _("set_name"), 1, _(""), _("UnityEngine"))));;
//	get_gameObject = reinterpret_cast<uintptr_t(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Component"), _("get_gameObject"), 0, _(""), _("UnityEngine"))));
//	//InverseTransformDirection = reinterpret_cast<vector3(*)(transform*, vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("InverseTransformDirection"), 1, _(""), _("UnityEngine"))));
//	//LookRotation = reinterpret_cast<vector4(*)(vector3, vector3 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Quaternion"), _("LookRotation"), 2, _(""), _("UnityEngine"))));
//	//set_rotation = reinterpret_cast<void(*)(transform*, vector4 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("set_rotation"), 1, _(""), _("UnityEngine"))));
//	//set_position = reinterpret_cast<void(*)(transform*, Vector3 value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("set_position"), 1, _(""), _("UnityEngine"))));
//	SetInt = reinterpret_cast<void(*)(uintptr_t material, rust::classes::string name, int value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Material"), _("SetInt"), 1, _(""), _("UnityEngine"))));
//	set_hideFlags = reinterpret_cast<void(*)(uintptr_t material, int value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Object"), _("set_hideFlags"), 1, _(""), _("UnityEngine"))));
//	Find = reinterpret_cast<uintptr_t(*)(rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Shader"), _("Find"), 1, _(""), _("UnityEngine"))));
//	SetColor = reinterpret_cast<void(*)(uintptr_t, rust::classes::string name, col value)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Material"), _("SetColor"), 2, _("name"), _("UnityEngine"), 1)));
//	get_Renderers = reinterpret_cast<rust::list<uintptr_t> *(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("SkinnedMultiMesh"), _("get_Renderers"), 0, _(""), _(""))));
//	get_material = reinterpret_cast<uintptr_t(*)(uintptr_t)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Renderer"), _("get_material"), 0, _(""), _("UnityEngine"))));
//	StringPool_Get = reinterpret_cast<unsigned int(*)(rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("StringPool"), _("Get"), 1, _("str"), _(""))));
//	set_timeScale = reinterpret_cast<void(*)(float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("set_timeScale"), 1, _(""), _("UnityEngine"))));
//	get_timeScale = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_timeScale"), 0, _(""), _("UnityEngine"))));
//	GetIndex = reinterpret_cast<int(*)(uintptr_t SkinSetCollection, float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("SkinSetCollection"), _("GetIndex"), 1, _(""), _(""))));
//	FloorToInt = reinterpret_cast<int (*)(float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Mathf"), _("FloorToInt"), 1, _(""), _("UnityEngine"))));
//	get_gravity = reinterpret_cast<Vector3(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Physics"), _("get_gravity"), 1, _(""), _("UnityEngine"))));
//	//FindBone = reinterpret_cast<transform * (*)(base_player*, rust::classes::string)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("FindBone"), 1, _(""), _(""))));
//	get_isAlive = reinterpret_cast<bool (*)(base_projectile*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Projectile"), _("get_isAlive"), 0, _(""), _(""))));
//	get_mousePosition = reinterpret_cast<Vector3(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Input"), _("get_mousePosition"), 0, _(""), _("UnityEngine"))));
//
//	containerWear = il2cpp::value(_("PlayerInventory"), _("containerWear"));
//	canWieldItems = il2cpp::value(_("BaseMountable"), _("canWieldItems"));
//	mounted = il2cpp::value(_("BasePlayer"), _("mounted"));
//	containerBelt = il2cpp::value(_("PlayerInventory"), _("containerBelt"));
//	itemList = il2cpp::value(_("ItemContainer"), _("itemList"));
//	integrity = il2cpp::value(_("Projectile"), _("integrity"));
//	weakspots = il2cpp::value(_("BaseHelicopter"), _("weakspots"));
//
//	model = il2cpp::value(_("BaseEntity"), _("model"));
//	gathering = il2cpp::value(_("BaseMelee"), _("gathering"));
//
//	lastHitTime = il2cpp::value(_("Chainsaw"), _("lastHitTime"));
//	lastHitMaterial = il2cpp::value(_("Chainsaw"), _("lastHitMaterial"));
//	landTime = il2cpp::value(_("PlayerWalkMovement"), _("landTime"));
//	jumpTime = il2cpp::value(_("PlayerWalkMovement"), _("jumpTime"));
//	groundTime = il2cpp::value(_("PlayerWalkMovement"), _("groundTime"));
//	gravityMultiplier = il2cpp::value(_("PlayerWalkMovement"), _("gravityMultiplier"));
//
//	damageProperties = il2cpp::value(_("BaseMelee"), _("damageProperties"));
//	movement = il2cpp::value(_("BasePlayer"), _("movement"));
//	_displayName = il2cpp::value(_("BasePlayer"), _("_displayName"));
//	player_inventory = il2cpp::value(_("BasePlayer"), _("inventory"));
//	clActiveItem = il2cpp::value(_("BasePlayer"), _("clActiveItem"));
//	playerModel = il2cpp::value(_("BasePlayer"), _("playerModel"));
//	clientTeam = il2cpp::value(_("BasePlayer"), _("clientTeam"));
//	playerFlags = il2cpp::value(_("BasePlayer"), _("playerFlags"));
//	clientTickInterval = il2cpp::value(_("BasePlayer"), _("clientTickInterval"));
//	eyes = il2cpp::value(_("BasePlayer"), _("eyes"));
//	lastSentTickTime = il2cpp::value(_("BasePlayer"), _("lastSentTickTime"));
//	modelState = il2cpp::value(_("BasePlayer"), _("modelState"));
//	input = il2cpp::value(_("BasePlayer"), _("input"));
//	userID = il2cpp::value(_("BasePlayer"), _("userID"));
//
//	newVelocity = il2cpp::value(_("PlayerModel"), _("newVelocity"));
//	isLocalPlayer = il2cpp::value(_("PlayerModel"), _("isLocalPlayer"));
//
//	nextAttackTime = il2cpp::value(_("AttackEntity"), _("nextAttackTime"));
//	timeSinceDeploy = il2cpp::value(_("AttackEntity"), _("timeSinceDeploy"));
//	deployDelay = il2cpp::value(_("AttackEntity"), _("deployDelay"));
//	repeatDelay = il2cpp::value(_("AttackEntity"), _("repeatDelay"));
//
//	_health = il2cpp::value(_("BaseCombatEntity"), _("_health"));
//	_maxHealth = il2cpp::value(_("BaseCombatEntity"), _("_maxHealth"));
//	lifestate = il2cpp::value(_("BaseCombatEntity"), _("lifestate"));
//
//	net = il2cpp::value(_("BaseNetworkable"), _("net"));
//
//	heldEntity = il2cpp::value(_("Item"), _("heldEntity"));
//
//	recoil = il2cpp::value(_("BaseProjectile"), _("recoil"));
//	automatic = il2cpp::value(_("BaseProjectile"), _("automatic"));
//
//	aimSway = il2cpp::value(_("BaseProjectile"), _("aimSway"));
//	aimSwaySpeed = il2cpp::value(_("BaseProjectile"), _("aimSwaySpeed"));
//	primaryMagazine = il2cpp::value(_("BaseProjectile"), _("primaryMagazine"));
//
//	aimCone = il2cpp::value(_("BaseProjectile"), _("aimCone"));
//	hipAimCone = il2cpp::value(_("BaseProjectile"), _("hipAimCone"));
//	aimConePenaltyMax = il2cpp::value(_("BaseProjectile"), _("aimConePenaltyMax"));
//	aimconePenaltyPerShot = il2cpp::value(_("BaseProjectile"), _("aimconePenaltyPerShot"));
//	stancePenaltyScale = il2cpp::value(_("BaseProjectile"), _("stancePenaltyScale"));
//
//	currentVelocity = il2cpp::value(_("Projectile"), _("currentVelocity"));
//	currentPosition = il2cpp::value(_("Projectile"), _("currentPosition"));
//	thickness_addr = il2cpp::value(_("Projectile"), _("thickness"));
//	mod = il2cpp::value(_("Projectile"), _("mod"));
//	hitTest = il2cpp::value(_("Projectile"), _("hitTest"));
//
//	//info = il2cpp::value(_("Item"), _("info"));
//
//	category = il2cpp::value(_("ItemDefinition"), _("category"));
//	itemid = il2cpp::value(_("ItemDefinition"), _("itemid"));
//	displayName = il2cpp::value(_("ItemDefinition"), _("displayName"));
//
//	viewOffset = il2cpp::value(_("PlayerEyes"), _("viewOffset"));
//
//	swimming = il2cpp::value(_("PlayerWalkMovement"), _("swimming"));
//	groundAngleNew = il2cpp::value(_("PlayerWalkMovement"), _("groundAngleNew"));
//	flying = il2cpp::value(_("PlayerWalkMovement"), _("flying"));
//
//	get_position = reinterpret_cast<Vector3(*)(uintptr_t transform)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("get_position"), 0, _(""), _("UnityEngine"))));
//
//	get_deltaTime = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_deltaTime"), 0, _(""), _("UnityEngine"))));
//
//	get_IsNpc = reinterpret_cast<bool(*)(uintptr_t player_model)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("PlayerModel"), _("get_IsNpc"), -1, _(""), _(""))));
//
//	get_time = reinterpret_cast<float(*)()>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Time"), _("get_time"), 0, _(""), _("UnityEngine"))));
//
//	GetProjectileVelocityScale = reinterpret_cast<float(*)(base_projectile*, bool max)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseProjectile"), _("GetProjectileVelocityScale"), 1, _("getMax"), _(""), 1)));
//
//	ClosestPoint = reinterpret_cast<Vector3(*)(base_player*, Vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseEntity"), _("ClosestPoint"), 1, _("position"), _(""), 1)));
//
//	StartAttackCooldown = reinterpret_cast<void(*)(base_projectile*, float)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("AttackEntity"), _("StartAttackCooldown"), 1, _(""), _(""))));
//
//	//get_transform = reinterpret_cast<transform * (*)(base_player*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Component"), _("get_transform"), 0, _(""), _("UnityEngine"))));
//
//	//InverseTransformPoint = reinterpret_cast<Vector3(*)(transform*, vector3)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("Transform"), _("InverseTransformPoint"), 1, _(""), _("UnityEngine"))));
//
//	ProcessAttack = reinterpret_cast<void(*)(base_projectile*, HitTest*)>(*reinterpret_cast<uintptr_t*>(il2cpp::method(_("BaseMelee"), _("ProcessAttack"), 1, _(""), _(""))));
//}

const unsigned short Crc16Table[256] = {
0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};

enum BoneList : int
{
	l_hip = 1,
	l_knee,
	l_foot,
	l_toe,
	l_ankle_scale,
	pelvis,
	penis,
	GenitalCensor,
	GenitalCensor_LOD0,
	Inner_LOD0,
	GenitalCensor_LOD1,
	GenitalCensor_LOD2,
	r_hip,
	r_knee,
	r_foot,
	r_toe,
	r_ankle_scale,
	spine1,
	spine1_scale,
	spine2,
	spine3,
	spine4,
	l_clavicle,
	l_upperarm,
	l_forearm,
	l_hand,
	l_index1,
	l_index2,
	l_index3,
	l_little1,
	l_little2,
	l_little3,
	l_middle1,
	l_middle2,
	l_middle3,
	l_prop,
	l_ring1,
	l_ring2,
	l_ring3,
	l_thumb1,
	l_thumb2,
	l_thumb3,
	IKtarget_righthand_min,
	IKtarget_righthand_max,
	l_ulna,
	neck,
	head,
	jaw,
	eyeTranform,
	l_eye,
	l_Eyelid,
	r_eye,
	r_Eyelid,
	r_clavicle,
	r_upperarm,
	r_forearm,
	r_hand,
	r_index1,
	r_index2,
	r_index3,
	r_little1,
	r_little2,
	r_little3,
	r_middle1,
	r_middle2,
	r_middle3,
	r_prop,
	r_ring1,
	r_ring2,
	r_ring3,
	r_thumb1,
	r_thumb2,
	r_thumb3,
	IKtarget_lefthand_min,
	IKtarget_lefthand_max,
	r_ulna,
	l_breast,
	r_breast,
	BoobCensor,
	BreastCensor_LOD0,
	BreastCensor_LOD1,
	BreastCensor_LOD2,
	collision,
	displacement
};

enum PlayerFlags : int
{
	Unused1 = 1,
	Unused2 = 2,
	IsAdmin = 4,
	ReceivingSnapshot = 8,
	Sleeping = 16,
	Spectating = 32,
	Wounded = 64,
	IsDeveloper = 128,
	Connected = 256,
	ThirdPersonViewmode = 1024,
	EyesViewmode = 2048,
	ChatMute = 4096,
	NoSprint = 8192,
	Aiming = 16384,
	DisplaySash = 32768,
	Relaxed = 65536,
	SafeZone = 131072,
	ServerFall = 262144,
	Workbench1 = 1048576,
	Workbench2 = 2097152,
	Workbench3 = 4194304,
};

typedef struct _UncStr
{
	char stub[0x10];
	int len;
	wchar_t str[1];
} *pUncStr;

class WeaponData
{
private:
	unsigned short CRC(unsigned char* pcBlock, unsigned short len)
	{
		unsigned short crc = 0xFFFF;
		while (len--)
			crc = (crc << 8) ^ Crc16Table[(crc >> 8) ^ *pcBlock++];
		return crc;
	}

public:

	char* ClassName() 
	{
		return (char*)safe_read(safe_read(safe_read(this + O::Item::heldEntity, DWORD64), DWORD64) + 0x10, DWORD64);
	}

	int GetID()
	{
		DWORD64 Info = safe_read((DWORD64)this + 0x20, DWORD64); // public ItemDefinition info;
		int ID = safe_read(Info + 0x18, int); // public int itemid;
		return ID;
	}

	Weapon Info() {
		int ID = GetID();
		for (Weapon k : info) {
			if (k.id == ID) {
				return k;
			}
		}
		return Weapon{ 0 };
	}

	wchar_t* GetShortName(int* len)
	{
		DWORD64 Info = safe_read(this + 0x20, DWORD64);
		pUncStr Str = ((pUncStr)safe_read(Info + 0x20, DWORD64));
		int leng = safe_read(Str + 0x10, int);
		if (!leng) return nullptr;
		if (len)*len = leng;
		return Str->str;
	}

	int LoadedAmmo()
	{
		const auto Held = safe_read(this + O::Item::heldEntity, DWORD64);
		if (Held <= 0)
			return 0;
		const auto Magazine = safe_read(Held + O::BaseProjectile::primaryMagazine, DWORD64);
		if (Magazine <= 0 || Magazine == 0x3F000000)
		{
			return 0;
		}
		const auto ammoType = safe_read(Magazine + 0x20, DWORD64);
		if (ammoType <= 0 || ammoType == 0x3F000000)
		{
			return 0;
		}
		const int ammo = safe_read(ammoType + 0x18, int);
		return ammo;
	}

	USHORT GetNameHash() 
	{
		int Len;
		UCHAR* ShortName = (UCHAR*)GetShortName(&Len);
		if (ShortName == nullptr) return 0;
		return CRC(ShortName, (Len * 2));
	}

	wchar_t* GetName() 
	{
		DWORD64 Info = safe_read(this + 0x20, DWORD64);
		DWORD64 DispName = safe_read(Info + 0x28, DWORD64);
		pUncStr Str = ((pUncStr)safe_read(DispName + 0x18, DWORD64)); // default
		if (!Str) return nullptr; return Str->str;
	}

	int GetUID() 
	{
		return safe_read(this + 0x28, int);
	}

	void AntiSpread()
	{
		if (Vars::Misc::AntiSpread)
		{
			DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
			safe_write(Held + O::BaseProjectile::stancePenalty, 0.f, float);
			safe_write(Held + O::BaseProjectile::aimconePenalty, 0.f, float);
			safe_write(Held + O::BaseProjectile::aimCone, 0.f, float);
			safe_write(Held + O::BaseProjectile::hipAimCone, 0.f, float);
			safe_write(Held + O::BaseProjectile::aimconePenaltyPerShot, 0.f, float);
		}
	}

	//void FastReload()
	//{
	//	if (Vars::Misc::FastReload)
	//	{
	//		DWORD64 Held = safe_read(this + 0x90, DWORD64);
	//		safe_write(Held + 0x2A8, 1, bool);
	//	}
	//}

	//inline void FatBullet()
	//{
	//	if (Vars::AimBot::FatBullet2)
	//	{
	//		DWORD64 Held = safe_read(this + 0x98, DWORD64); //	private EntityRef heldEntity; // 0x90
	//		DWORD64 List = safe_read(Held + 0x338, DWORD64); //private List`1<Projectile> createdProjectiles; // 0x338
	//		int size = safe_read(List + 0x18, DWORD64);
	//		List = safe_read(List + 0x10, DWORD64);
	//		{
	//			for (int i = 0; i < size; ++i)
	//			{
	//				UINT64 Item = safe_read(List + 0x20 + (i * 0x8), UINT64);
	//				safe_write(Item + 0x2C, 1.5f, float); //public float thickness; // 0x2C??
	//			}
	//		}

	//	}
	//}

	//void FastMelee()
	//{
	//	if (Vars::Misc::FastMeele)
	//	{
	//		DWORD64 HeldItem = safe_read(this + 0x98, DWORD64);
	//		safe_write(HeldItem + 0x240, 5.f, float); //private float speedFast;
	//	}
	//}

	void RapidFire() {
		if (Vars::Misc::RapidFire) {
			DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
			safe_write(Held + O::AttackEntity::repeatDelay, 0.001f, float);
		}
	}

	void NoRecoil()
	{
		if (Vars::Misc::NoRecoil)
		{
			DWORD64 Held = safe_read((const uintptr_t)this + O::Item::heldEntity, DWORD64);
			DWORD64 recoil = safe_read(Held + O::BaseProjectile::recoil, DWORD64);
			float RecoilMinYaw = safe_read(recoil + O::RecoilProperties::recoilYawMin, float);
			float RecoilMaxYaw = safe_read(recoil + O::RecoilProperties::recoilYawMax, float);
			float RecoilMinPitch = safe_read(recoil + O::RecoilProperties::recoilPitchMin, float);
			float RecoilMaxPitch = safe_read(recoil + O::RecoilProperties::recoilPitchMax, float);
			safe_write(recoil + O::RecoilProperties::recoilYawMin, RecoilMinYaw, float);
			safe_write(recoil + O::RecoilProperties::recoilYawMax, RecoilMaxYaw, float);
			safe_write(recoil + O::RecoilProperties::recoilPitchMin, RecoilMinPitch, float);
			safe_write(recoil + O::RecoilProperties::recoilPitchMax, RecoilMaxPitch, float);
		}
	}

	void SetAutomatic() {

		if (Vars::Misc::Automatic) {
			DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
			safe_write(Held + O::BaseProjectile::automatic, 1, bool);
		}
	}

	void SuperEoka() {
		if (Vars::Misc::SuperEoka) {

			DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
			safe_write(Held + O::BowWeapon::attackReady, 1.f, float);
			safe_write(Held + O::BowWeapon::wasAiming, true, bool);
		}
	}

	void SuperBow()
	{
		if (Vars::Misc::SuperBow)
		{
			DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
			safe_write(Held + O::BowWeapon::attackReady, 1, bool);
			safe_write(Held + O::BowWeapon::arrowBack, 3.f, float);
			//РАБОТАЕТ
		}
	}

	//void FastCompoundBow() {
	//	if (Vars::Misc::FastCompBow)
	//	{
	//		DWORD64 Held = safe_read(this + 0x98, DWORD64);
	//		DWORD64 CompoundBow = safe_read(Held + 0x360, DWORD64); //public float stringHoldDurationMax;
	//		safe_write(Held + 0x360, 0.f, float);
	//	}
	//}

	//void BuildAsUWant()
	//{
	//	DWORD64 Held = safe_read(this + oHeldEntity, DWORD64);
	//	DWORD64 Construction = safe_read(Held + oHornOrigin, DWORD64);
	//	if (Vars::Misc::BuildAsUWant && FC(user32, GetAsyncKeyState, Vars::Misc::buildkey)) safe_write(Construction + 0xEC, 15, int);
	//	if (!Vars::Misc::BuildAsUWant) safe_write(Construction + 0xEC, 180, int);
	//	// private Vector3 rotationOffset
	//}

	void LongHand()
	{
		DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
		safe_write(Held + O::BaseMelee::maxDistance, 4.5f, float);  //private Transform attachmentBoneCache; // public float maxDistance;
	}

	void FatHand()
	{
		DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
		safe_write(Held + O::BaseMelee::attackRadius, 15.f, float);
	}

	void RunOnHit()
	{
		DWORD64 Held = safe_read(this + O::Item::heldEntity, DWORD64);
		safe_write(Held + O::BaseMelee::blockSprintOnAttack, 0, int);
	}

};

class BasePlayer
{
public:
	//*** base entity info ***//
	float GetHealth() 
	{
		return safe_read(this + O::BaseCombatEntity::_health, float);
	}

	void AddFlag(int flag) 
	{
		DWORD64 mstate = safe_read(this + 0x588, DWORD64);
		int flags = safe_read(mstate + 0x24, int);
		safe_write(mstate + 0x24, flags |= flag, int);
	}

	float Time() {
		return safe_read(this + 0x5CC, float);
	}

	void SetRemoveFlag(int flag) 
	{
		DWORD64 mstate = safe_read(this + O::BasePlayer::modelState, DWORD64);

		int flags = safe_read(mstate + O::ModelState::flags, int);
		safe_write(mstate + O::ModelState::flags, flags &= flag, int);
	}

	void SetFov()
	{
		auto klass = safe_read(Vars::Storage::gBase + 0x3298EE0, DWORD64);
		auto static_fields = safe_read(klass + 0xB8, DWORD64);
		safe_write(static_fields + 0x18, Vars::Misc::FovRange, float);
	}

	void Zoom(bool state)
	{

		if (FC(user32, GetAsyncKeyState, Vars::Misc::zoomkey))
		{

			auto klass = safe_read(Vars::Storage::gBase + 0x3298EE0, DWORD64); //ConVar.Graphics_TypeInfo //0x2965510 old
			auto static_fields = safe_read(klass + 0xB8, DWORD64);
			safe_write(static_fields + 0x18, 20.f, float);
		}
		else
		{
			auto klass = safe_read(Vars::Storage::gBase + 0x3298EE0, DWORD64); //ConVar.Graphics_TypeInfo //0x2965510 old
			auto static_fields = safe_read(klass + 0xB8, DWORD64);
			safe_write(static_fields + 0x18, Vars::Misc::FovRange, float);
		}
	}

	void LongNeck() {
		DWORD64 eyes = safe_read(this + O::BasePlayer::eyes, DWORD64); //public PlayerEyes eyes; // 0x640
		safe_write(eyes + 0x38, Vector3(0, 50.f, 0), Vector3); //private Vector3 viewOffset; // 0x38
	}

	const wchar_t* GetName()
	{
		pUncStr Str = ((pUncStr)(safe_read(this + O::BasePlayer::_displayName, DWORD64)));
		if (!Str) return StrW(L""); return Str->str;
	}

	Vector3 GetVelocity() 
	{
		DWORD64 PlayerModel = safe_read(this + O::BasePlayer::playerModel, DWORD64);
		return safe_read(PlayerModel + O::PlayerModel::newVelocity, Vector3);
	}

	bool IsNpc() {
		DWORD64 PlayerModel = safe_read(this + O::BasePlayer::playerModel, DWORD64); //	public PlayerModel playerModel;
		return safe_read(PlayerModel + 0x304, bool);//private bool <IsNpc>k__BackingField;
	}

	bool IsVisible() {
		if (Vars::AimBot::VisibleCheck) {
			DWORD64 PlayerModel = safe_read(this + O::BasePlayer::playerModel, DWORD64);
			return safe_read(PlayerModel + 0x248, bool);
		}
		else return true;
	}

	float GetTickTime() {
		return safe_read(this + O::BasePlayer::lastSentTickTime, float);
	}

	bool IsValid(bool LPlayer = false) 
	{
		return (((LPlayer || Vars::Visuals::IgnoreSleepers) ? !HasFlags(16) : true) && !IsDead() && (GetHealth() >= 0.8f));
	}

	bool HasFlags(int Flg) 
	{
		return (safe_read(this + O::BasePlayer::playerFlags, int) & Flg);
	}


	Vector3 GetBoneByID(BoneList BoneID) 
	{
		return GetPosition(GetTransform(BoneID));
	}

	int GetTeamSize()
	{
		DWORD64 ClientTeam = safe_read(this + O::BasePlayer::clientTeam, DWORD64);
		DWORD64 members = safe_read(ClientTeam + 0x28, DWORD64);//	private ListHashSet<ILOD> members; //public PlayerInventory inventory; // 0x28 ���  public List<PlayerTeam.TeamMember> members; // 0x28
		return safe_read(members + 0x18, DWORD64);
	}

	DWORD64 GetTeammateByPos(int Id)
	{
		DWORD64 ClientTeam = safe_read(this + O::BasePlayer::clientTeam, DWORD64);
		DWORD64 members = safe_read(ClientTeam + 0x30, DWORD64);
		DWORD64 List = safe_read(members + 0x10, DWORD64);
		DWORD64 player = safe_read(List + 0x20 + (Id * 0x8), DWORD64);
		return safe_read(player + 0x20, DWORD64);
	}

	bool IsTeamMate(DWORD64 SteamID) {
		bool ret = false;

		for (int i = 0; i < 8; i++) {
			if (GetTeammateByPos(i) == SteamID) {
				ret = true;
				break;
			}
		}
		return ret;
	}

	bool IsDead()
	{
		if (!this) return true;
		return safe_read(this + O::BaseCombatEntity::lifestate, bool);;
	}

	bool HasFlag(int PlayerFlag)
	{
		return (safe_read(this + O::BasePlayer::playerFlags, int) & PlayerFlag);
	}

	bool IsSleeping()
	{
		if (!this) return false;
		return HasFlag(Sleeping);
	}

	bool IsWounded()
	{
		if (!this) return false;
		return HasFlag(Wounded);
	}

	DWORD64 GetSteamID() 
	{
		return safe_read(this + O::BasePlayer::userID, DWORD64);
	}

	//*** localplayer ***//
	bool IsMenu() 
	{
		if (!this) return true;
		DWORD64 Input = safe_read(this + O::BasePlayer::input, DWORD64);
		return !(safe_read(Input + O::PlayerInput::hasKeyFocus, bool));
	}

	void SetVA(const Vector2& VA) 
	{
		DWORD64 Input = safe_read(this + O::BasePlayer::input, DWORD64);
		Vector2 RA = { 0.f, 0.f };
		safe_write(Input + O::PlayerInput::recoilAngles, RA, Vector2);
	}

	void SetRA() 
	{
		DWORD64 Input = safe_read(this + O::BasePlayer::input, DWORD64);
		Vector2 RA = { 0.f, 0.f };
		safe_write(Input + O::PlayerInput::recoilAngles, RA, Vector2);
	}

	Vector2 GetVA() 
	{
		DWORD64 Input = safe_read(this + O::BasePlayer::input, DWORD64);
		return safe_read(Input + 0x3C, Vector2);
	}

	Vector2 GetRA()
	{
		DWORD64 Input = safe_read(this + O::BasePlayer::input, DWORD64);
		return safe_read(Input + O::PlayerInput::recoilAngles, Vector2); //public Vector3 recoilAngles;
	}


	WeaponData* GetWeaponInfo(int Id) 
	{
		DWORD64 Inventory = safe_read(this + O::BasePlayer::inventory, DWORD64);
		DWORD64 Belt = safe_read(Inventory + 0x28, DWORD64);
		DWORD64 ItemList = safe_read(Belt + 0x38, DWORD64);// public List<Item> itemList;
		DWORD64 Items = safe_read(ItemList + 0x10, DWORD64); //	public List<InventoryItem.Amount> items;
		return (WeaponData*)safe_read(Items + 0x20 + (Id * 0x8), DWORD64);
	}

	WeaponData* GetActiveWeapon()
	{
		int ActUID = safe_read(this + O::BasePlayer::clActiveItem, int);
		if (!ActUID) return nullptr;
		WeaponData* ActiveWeapon;
		for (int i = 0; i < 6; i++)
			if (ActUID == (ActiveWeapon = GetWeaponInfo(i))->GetUID()) {
				return ActiveWeapon;
			}
		return 0;
	}

	////*** cheat func ***//
	//void WalkWater()
	//{
	//	DWORD64 Movement = safe_read(this + oMovement, DWORD64);
	//	if (!Movement)
	//		return;

	//	static bool x130 = safe_read(Movement + oFlying, bool);
	//	static float xB0 = safe_read(Movement + oGroundAngleNew, float);
	//	static float x74 = safe_read(Movement + oGravityMultiplier, float);
	//	static float x78 = safe_read(Movement + oGravityMultiplierSwimming, float);

	//	bool state = Vars::Misc::WalkOnWater && GetAsyncKeyState(0x58);

	//	if (Vars::Misc::WalkOnWater)
	//	{
	//		safe_write(Movement + oFlying, 1, bool);
	//		safe_write(Movement + oGroundAngleNew, 0.f, float);
	//		safe_write(Movement + oGravityMultiplier, 0.f, float);
	//		safe_write(Movement + oGravityMultiplierSwimming, 1.f, float);
	//	}
	//	else
	//	{
	//		safe_write(Movement + oFlying, x130, bool);
	//		safe_write(Movement + oGroundAngleNew, xB0, float);
	//		safe_write(Movement + oGravityMultiplier, x74, float);
	//		safe_write(Movement + oGravityMultiplierSwimming, x78, float);
	//	}
	//}

	void FakeAdmin(int Val) 
	{
		int Flags = safe_read(this + O::BasePlayer::playerFlags, int);
		safe_write(this + O::BasePlayer::playerFlags, (Flags |= 4), int);

	}

	void Pizda228() {
		if (Vars::Visuals::NightMode) 
		{
			static DWORD64 dwGameObjectManager = 0;
			UINT64 ObjMgr = safe_read(GetModBase(StrW((L"UnityPlayer.dll"))) + 0x17C1F18, UINT64);
			UINT64 end = safe_read(ObjMgr, UINT64);
			DWORD64 Obj = safe_read(ObjMgr + 0x8, DWORD64); (Obj && (Obj != safe_read(ObjMgr, DWORD64))); Obj = safe_read(Obj + 0x8, DWORD64);
			DWORD64 GameObject = safe_read(Obj + 0x10, DWORD64);
			DWORD64 ObjClass = safe_read(GameObject + 0x30, DWORD64);
			DWORD64 Entity = safe_read(ObjClass + 0x18, DWORD64);
			DWORD64 Dome = safe_read(Entity + 0x28, DWORD64);
			DWORD64 TodCycle2 = safe_read(Dome + 0x38, DWORD64);
			safe_write(TodCycle2 + 0x10, 01.00f, float);
			return;
		}
		return;
	}

	void SpiderMan() 
	{
		DWORD64 Movement = safe_read(this + O::BasePlayer::movement, DWORD64);
		safe_write(Movement + O::PlayerWalkMovement::groundAngle, 0.f, float);
		safe_write(Movement + O::PlayerWalkMovement::groundAngleNew, 0.f, float);
	}


	void SetWaterLevel(float val) {
		DWORD64 mstate = safe_read(this + 0x14, DWORD64);
		safe_write(mstate + 0x430, val, float);

		if (Vars::Misc::SwimOnGround) {
			LocalPlayer->SetWaterLevel(0.65f);
		}
	}

	BasePlayer* LocalPlayer = 0;

	void FakeThirdPerson(int Val) {
		int Flags = safe_read(this + 0x5F8, int); //public BasePlayer.PlayerFlags playerFlags;
		safe_write(this + 0x5F8, (Flags |= 1024), int);
	}

	void NoSway() 
	{
		safe_write(this + O::BasePlayer::clothingAccuracyBonus, 1.f, float);
	}

	void NoBlockAiming() 
	{
		safe_write(this + O::BasePlayer::clothingAccuracyBonus, false, bool);
	}

	void NoHeavyReduct()
	{
		float Reduct = safe_read(this + O::BasePlayer::clothingMoveSpeedReduction, float);
		if (Reduct == 0.f) { safe_write(this + O::BasePlayer::clothingMoveSpeedReduction, -0.1f, float); }
		else if ((Reduct > 0.15f) && (Reduct < 0.35f)) {
			safe_write(this + O::BasePlayer::clothingMoveSpeedReduction, 0.15f, float);
		}
		else if (Reduct > 0.39f) {
			safe_write(this + O::BasePlayer::clothingMoveSpeedReduction, 0.15f, float);
		}
	}

	void SetGravity(float val) 
	{
		DWORD64 Movement = safe_read(this + O::BasePlayer::movement, DWORD64);
		safe_write(Movement + O::PlayerWalkMovement::gravityMultiplier, val, float);
	}

	Vector3 GetPosition()
	{
		return GetPosition(GetTransform(r_foot)).midPoint(GetPosition(GetTransform(l_foot)));
	}
	typedef Vector3(__stdcall* Transform)(UINT64);
	Vector3 GetPosition(ULONG_PTR pTransform) {
		if (!pTransform) return Vector3();
		Transform original = (Transform)(Vars::Storage::gBase + O::UnityEngine_Transform::get_position);
		Vector3 res = original(pTransform);
		return res;
	}
	DWORD64 GetTransform(int bone) {
		DWORD64 player_model = safe_read(this + O::BaseEntity::model, DWORD64);// public Model model;_public class BaseEntity : BaseNetworkable, IProvider, ILerpTarget, IPrefabPreProcess // TypeDefIndex: 8714
		DWORD64 boneTransforms = safe_read(player_model + 0x48, DWORD64);//public Transform[] boneTransforms;
		DWORD64 BoneValue = safe_read((boneTransforms + (0x20 + (bone * 0x8))), DWORD64);
		return BoneValue;
	}
};

//Base Player
class LPlayerBase
{
public:
	BasePlayer* BasePlayer = nullptr;
	Matrix4x4* pViewMatrix = nullptr;
	bool WorldToScreen(const Vector3& EntityPos, Vector2& ScreenPos)
	{
		if (!pViewMatrix) return false;
		Vector3 TransVec = Vector3(pViewMatrix->_14, pViewMatrix->_24, pViewMatrix->_34);
		Vector3 RightVec = Vector3(pViewMatrix->_11, pViewMatrix->_21, pViewMatrix->_31);
		Vector3 UpVec = Vector3(pViewMatrix->_12, pViewMatrix->_22, pViewMatrix->_32);
		float w = Math::Dot(TransVec, EntityPos) + pViewMatrix->_44;
		if (w < 0.098f) return false;
		float y = Math::Dot(UpVec, EntityPos) + pViewMatrix->_42;
		float x = Math::Dot(RightVec, EntityPos) + pViewMatrix->_41;
		ScreenPos = Vector2((Vars::Global::ScreenWidth / 2) * (1.f + x / w), (Vars::Global::ScreenHigh / 2) * (1.f - y / w));
		return true;
	}
};

float GetBulletSpeedPS(Weapon tar, int ammo)
{
	if (ammo == 0) return tar.ammo[0].speed;
	for (Ammo am : tar.ammo) {
		for (int id : am.id) {
			if (id == ammo) {
				return am.speed;
			}
		}
		if (am.id[0] == 0) return am.speed;
	}
	return 250.f;
}

float GetGravityPS(int ammoid) {
	switch (ammoid) {
	case 14241751:
		return 1.f;
	case -1234735557:
		return 0.75f;
	case 215754713:
		return 0.75f;
	case -1023065463:
		return 0.5f;
	case -2097376851:
		return 0.75f;
	case -1321651331:
		return 1.25f;
	default:
		return 1.f;
	}
}

DECLSPEC_NOINLINE void Flex() 
{
	FC(kernel32, Sleep, 0);
}

LPlayerBase LocalPlayer;